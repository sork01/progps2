// Mikael Forsberg <miforsb@kth.se>
// Robin Gunning <rgunning@kth.se>
// Skapad 2015-11-18

import java.util.Arrays;
import java.util.List;
import java.util.Stack;
import java.util.LinkedList;
import java.util.Scanner;
import java.lang.StringBuilder;

/**
 * Parser reads a stream of tokens generated by
 * a lexer and creates a parse tree according
 * to a grammar.
 *
 * @author Mikael Forsberg
 * @author Robin Gunning
 * @version 2015-11-18
 */
public class Parser
{
    /**
     * The initial state of the parser.
     */
    public static final int ST_PROGRAM = 0;
    
    /**
     * A state where the parser will accept end-of-file or
     * more statements.
     */
    public static final int ST_PROGRAM_MORE = 1;
    
    /**
     * A state where the parser will only accept a full statement.
     */
    public static final int ST_STATEMENT = 2;
    
    /**
     * The final state of the parser.
     */
    public static final int ST_DONE = 3;
    
    /**
     * A state where the parser will only accept the argument and
     * end-of-statement parts of a FORW statement, and then commits
     * the FORW statement to the parse tree.
     */
    public static final int ST_FORW = 4;
    
    /**
     * A state where the parser will only accept the argument and
     * end-of-statement parts of a BACK statement, and then commits
     * the BACK statement to the parse tree.
     */
    public static final int ST_BACK = 5;
    
    /**
     * A state where the parser will only accept the argument and
     * end-of-statement parts of a LEFT statement, and then commits
     * the LEFT statement to the parse tree.
     */
    public static final int ST_LEFT = 6;
    
    /**
     * A state where the parser will only accept the argument and
     * end-of-statement parts of a RIGHT statement, and then commits
     * the RIGHT statement to the parse tree.
     */
    public static final int ST_RIGHT = 7;
    
    /**
     * A state where the parser will only accept the end-of-statement
     * part of an UP statement, and then commits
     * the UP statement to the parse tree.
     */
    public static final int ST_UP = 8;
    
    /**
     * A state where the parser will only accept the end-of-statement
     * part of a DOWN statement, and then commits
     * the DOWN statement to the parse tree.
     */
    public static final int ST_DOWN = 9;
    
    /**
     * A state where the parser will only accept the color-hex and
     * end-of-statement parts of a COLOR statement, and then commits
     * the COLOR statement to the parse tree.
     */
    public static final int ST_COLOR = 10;
    
    /**
     * A state where the parser will require the integer argument
     * of a REP statement, followed by either a quoted section
     * of one or more statements or a single non-quoted statement.
     */
    public static final int ST_REP = 11;
    
    /**
     * A state where the parser will accept another statement, or
     * a single quote ending a section of quoted statements.
     */
    public static final int ST_REP_MORE = 12;
    
    /**
     * A state where the parser commits a completed REP statement
     * to the parse tree.
     */
    public static final int ST_REP_END = 13;
    
    /**
     * A state where the parser requires a quote to end a quoted
     * section of statements, and then commits the REP statement
     * to the parse tree.
     */
    public static final int ST_REP_END_QUOTED = 14;
    
    /**
     * Creates a new Parser.
     * 
     * @param L Lexer to use
     */
    public Parser(Lexer L)
    {
        lexer = L;
    }
    
    /**
     * Helper method for calling nextToken(List<Token.Type>)
     * 
     * @param req Accepted token type
     */
    public Token nextToken(Token.Type req)
    {
        return nextToken(Arrays.asList(req));
    }
    
    /**
     * Helper method for calling nextToken(List<Token.Type>)
     * 
     * @param req1 First accepted token type
     * @param req2 Second accepted token type
     */
    public Token nextToken(Token.Type req1, Token.Type req2)
    {
        return nextToken(Arrays.asList(req1, req2));
    }
    
    /**
     * Take a token from the lexer. If the lexer does not have any more
     * tokens, returns NULL. Otherwise, if the token is one of the types
     * contained in the given list of accepted types, return the token,
     * otherwise return NULL. If the list of accepted types does not
     * contain comments or whitespace, these types will be automatically
     * skipped over.
     * 
     * @param req Accepted token types
     */
    public Token nextToken(List<Token.Type> req)
    {
        if (!lexer.hasNext())
        {
            return null;
        }
        
        processed.add(0);
        
        while (true)
        {
            Token tok = lexer.next();
            
            if (tok == null)
            {
                return null;
            }
            
            processed.add(processed.pop() + tok.text.length());
            
            if (req.contains(tok.type))
            {
                return tok;
            }
            else if (tok.type == Token.Type.COMMENT || tok.type == Token.Type.WHITESPACE)
            {
                continue;
            }
            else
            {
                return null;
            }
        }
    }
    
    /**
     * Helper method for syntax error.
     */
    public LinkedList<Command> parseError()
    {
        System.out.format("Syntaxfel p√• rad %d", lexer.line());
        return null;
    }
    
    /**
     * Rewind the lexer to the position before the last call to
     * nextToken()
     */
    public void putBack()
    {
        Integer p = processed.pop();
        lexer.putBack(p);
    }
    
    /**
     * Parse the token stream. If the stream conforms to the grammar,
     * returns the parse tree, otherwise returns NULL.
     */
    public LinkedList<Command> parse()
    {
        Stack<Integer> states = new Stack<Integer>();
        states.push(ST_PROGRAM);
        
        LinkedList<Command> parsetree = new LinkedList<Command>();
        Stack<LinkedList<Command>> treeptr = new Stack<LinkedList<Command>>();
        
        treeptr.push(parsetree);
        
        Token tok;
        
        List<Token.Type> toks_stmt = Arrays.asList(
            Token.Type.KEYWORD_FORW,
            Token.Type.KEYWORD_BACK,
            Token.Type.KEYWORD_LEFT,
            Token.Type.KEYWORD_RIGHT,
            Token.Type.KEYWORD_UP,
            Token.Type.KEYWORD_DOWN,
            Token.Type.KEYWORD_COLOR,
            Token.Type.KEYWORD_REP);
        
        while (true)
        {
            Integer state = states.pop();
            
            switch (state)
            {
                case ST_PROGRAM:
                    states.push(ST_PROGRAM_MORE);
                    states.push(ST_STATEMENT);
                    break;
                case ST_PROGRAM_MORE:
                    tok = nextToken(toks_stmt);
                    putBack();
                    
                    if (tok == null)
                    {
                        states.push(ST_DONE);
                    }
                    else
                    {
                        states.push(ST_PROGRAM_MORE);
                        states.push(ST_STATEMENT);
                    }
                    break;
                case ST_STATEMENT:
                    tok = nextToken(toks_stmt);
                    
                    if (tok == null)
                    {
                        return parseError();
                    }
                    
                    switch (tok.type)
                    {
                        case KEYWORD_FORW:
                            states.push(ST_FORW);
                            break;
                        case KEYWORD_BACK:
                            states.push(ST_BACK);
                            break;
                        case KEYWORD_LEFT:
                            states.push(ST_LEFT);
                            break;
                        case KEYWORD_RIGHT:
                            states.push(ST_RIGHT);
                            break;
                        case KEYWORD_UP:
                            states.push(ST_UP);
                            break;
                        case KEYWORD_DOWN:
                            states.push(ST_DOWN);
                            break;
                        case KEYWORD_COLOR:
                            states.push(ST_COLOR);
                            break;
                        case KEYWORD_REP:
                            states.push(ST_REP);
                            break;
                    }
                    break;
                case ST_FORW:
                    if (nextToken(Token.Type.WHITESPACE) == null)
                    {
                        return parseError();
                    }
                    
                    tok = nextToken(Token.Type.POSITIVE_INTEGER);
                    
                    if (tok == null)
                    {
                        return parseError();
                    }
                    
                    if (nextToken(Token.Type.END_STATEMENT) == null)
                    {
                        return parseError();
                    }
                    
                    treeptr.peek().add(new MovementCommand(MovementCommand.Direction.FORWARD, Integer.parseInt(tok.text)));
                    break;
                case ST_BACK:
                    if (nextToken(Token.Type.WHITESPACE) == null)
                    {
                        return parseError();
                    }
                    
                    tok = nextToken(Token.Type.POSITIVE_INTEGER);
                    
                    if (tok == null)
                    {
                        return parseError();
                    }
                    
                    if (nextToken(Token.Type.END_STATEMENT) == null)
                    {
                        return parseError();
                    }
                    
                    treeptr.peek().add(new MovementCommand(MovementCommand.Direction.BACK, Integer.parseInt(tok.text)));
                    break;
                case ST_LEFT:
                    if (nextToken(Token.Type.WHITESPACE) == null)
                    {
                        return parseError();
                    }
                    
                    tok = nextToken(Token.Type.POSITIVE_INTEGER);
                    
                    if (tok == null)
                    {
                        return parseError();
                    }
                    
                    if (nextToken(Token.Type.END_STATEMENT) == null)
                    {
                        return parseError();
                    }
                    
                    treeptr.peek().add(new RotationCommand(RotationCommand.Direction.LEFT, Integer.parseInt(tok.text)));
                    break;
                case ST_RIGHT:
                    if (nextToken(Token.Type.WHITESPACE) == null)
                    {
                        return parseError();
                    }
                    
                    tok = nextToken(Token.Type.POSITIVE_INTEGER);
                    
                    if (tok == null)
                    {
                        return parseError();
                    }
                    
                    if (nextToken(Token.Type.END_STATEMENT) == null)
                    {
                        return parseError();
                    }
                    
                    treeptr.peek().add(new RotationCommand(RotationCommand.Direction.RIGHT, Integer.parseInt(tok.text)));
                    break;
                case ST_UP:
                    if (nextToken(Token.Type.END_STATEMENT) == null)
                    {
                        return parseError();
                    }
                    
                    treeptr.peek().add(new PenCommand(PenCommand.State.UP));
                    break;
                case ST_DOWN:
                    if (nextToken(Token.Type.END_STATEMENT) == null)
                    {
                        return parseError();
                    }
                    
                    treeptr.peek().add(new PenCommand(PenCommand.State.DOWN));
                    break;
                case ST_COLOR:
                    if (nextToken(Token.Type.WHITESPACE) == null)
                    {
                        return parseError();
                    }
                    
                    tok = nextToken(Token.Type.COLOR_HEX);
                    
                    if (tok == null)
                    {
                        return parseError();
                    }
                    
                    if (nextToken(Token.Type.END_STATEMENT) == null)
                    {
                        return parseError();
                    }
                    
                    treeptr.peek().add(new ColorCommand(tok.text));
                    break;
                case ST_REP:
                    if (nextToken(Token.Type.WHITESPACE) == null)
                    {
                        return parseError();
                    }
                    
                    tok = nextToken(Token.Type.POSITIVE_INTEGER);
                    
                    if (tok == null)
                    {
                        return parseError();
                    }
                    
                    if (nextToken(Token.Type.WHITESPACE) == null)
                    {
                        return parseError();
                    }
                    
                    RepeatCommand rep = new RepeatCommand(Integer.parseInt(tok.text));
                    treeptr.peek().add(rep);
                    treeptr.push(rep.commands);
                    
                    boolean quoted = true;
                    
                    if (nextToken(Token.Type.QUOTE) == null)
                    {
                        putBack();
                        quoted = false;
                    }
                    
                    if (quoted)
                    {
                        states.push(ST_REP_MORE);
                        states.push(ST_STATEMENT);
                    }
                    else
                    {
                        states.push(ST_REP_END);
                        states.push(ST_STATEMENT);
                    }
                    break;
                case ST_REP_MORE:
                    if (nextToken(Token.Type.QUOTE) == null)
                    {
                        putBack();
                        states.push(ST_REP_MORE);
                        states.push(ST_STATEMENT);
                    }
                    else
                    {
                        putBack();
                        states.push(ST_REP_END_QUOTED);
                    }
                    break;
                case ST_REP_END:
                    treeptr.pop();
                    break;
                case ST_REP_END_QUOTED:
                    if (nextToken(Token.Type.QUOTE) == null)
                    {
                        return parseError();
                    }
                    
                    treeptr.pop();
                    break;
                case ST_DONE:
                    while (nextToken(Token.Type.WHITESPACE, Token.Type.COMMENT) != null);
                    
                    if (lexer.hasNext())
                    {
                        return parseError();
                    }
                    else
                    {
                        return parsetree;
                    }
                    //break; // unreachable
                default:
                    throw new RuntimeException("all gone bad");
                    //break; // unreachable
            }
        }
    }
    
    /**
     * Lexer used by the parser.
     */
    private Lexer lexer;
    
    /**
     * Stack of lexer positions between calls to nextToken()
     */
    private Stack<Integer> processed = new Stack<Integer>();
}
